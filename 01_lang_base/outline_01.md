# Эрланг на практике. Вступление, типы данных.

## Вступление

С одной стороны, изучить эрланг довольно легко. Сам язык простой, есть
несколько хороших книг про него -- бери да учи.

Может быть вы от кого-то слышали, что эрланг можно освоить за 2
недели, и потом можно сразу писать код в реальных проектах.  Это почти
правда.

Но это если вы попали в команду опытных эрланг-разработчиков и пишите код
под их присмотром :)

И есть некоторый разрыв между изучением языка по книгам и реальной работой.
Будет много упражнений, несколько небольших проектов, и
большой проект в конце курса.


### Изучай Erlang во имя добра!
Фред Хеберт

[Переведенная на русский язык](http://www.ozon.ru/context/detail/id/28953563/)

В оригинале:
[Learn You Some Erlang for Great Good!: A Beginner's Guide
Fred Hebert](http://www.amazon.com/Learn-Some-Erlang-Great-Good/dp/1593274351/)

[Бесплатная html версия](http://learnyousomeerlang.com/)


### Программирование в Erlang
Франческо Чезарини, Симон Томпсон

[Переведенная на русский язык](http://www.ozon.ru/context/detail/id/30671701/)

В оригинале:
[Erlang Programming
Francesco Cesarini, Simon Thompson](http://www.amazon.com/Erlang-Programming-Francesco-Cesarini/dp/0596518188/)


### Programming Erlang: Software for a Concurrent World (Pragmatic Programmers)
Joe Armstrong

[В оригинале](http://www.amazon.com/Programming-Erlang-Concurrent-Pragmatic-Programmers/dp/193778553X/)


### Erlang and OTP in Action
Martin Logan, Eric Merritt, Richard Carlsson

[В оригинале](http://www.amazon.com/Erlang-OTP-Action-Martin-Logan/dp/1933988789/)


## Чем хорош эрланг

Наверняка вы уже наслышаны о легковесных потоках, передаче сообщений,
устойчивости к ошибкам и о горячем обновлении кода.

Виртуальная машина эрланг имеет свою реализацию многопоточности, свои
планировщики, работающие поверх процессов операционной системы, и
умеющие создавать и управлять десятками и сотнями тысяч потоков.
Новый поток стартует за **3-5 микросекунд** (не миллисекунд, а микросекунд)
и занимает около **2.5 Кб** памяти.

У каждого потока своя область памяти и свой сборщик мусора.  Нету
разделяемой между потоками памяти.

Потоки обмениваются сообщениями друг с другом. При этом данные копируются
из памяти одного потока в память другого потока.

Эрланг предлагает средства (примитивы языка и архитектурные паттерны),
значительно повышающие устойчивость к ошибкам.

Ну и горячее обновление кода.


## Типы данных

11 штук.

 - численные: integer, float;
 - атомы;
 - структуры: list, tuple, map;
 - идентификаторы: pid, port, reference;
 - функции;
 - binary;


### integer

Целое число со знаком. Диапазон значений не ограничен.

В большинстве случаев 1 машинное слово (4 байта на 32-х
разрядной платформе, 8 байт на 64-х разрядной). Если число большое, и
для его хранения не хватает машинного слова, то памяти выделяется
больше.

```erlang
1> 2#101010.
42
2> 8#0677.
447
3> 16#AE.
174
```

### float

Число с плавающей точкой. Как и в большинстве других языков, реализованно по стандарту
[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).
Соответственно, занимает 8 байт памяти. Может быть представлено в разных видах.

```erlang
1> 2.5.
2.5
2> 3.14159.
3.14159
3> -2.3e+6.
-2.3e6
4> 23.56E-27.
2.356e-26
```

И подвержено потере точности при вычислениях, точно так же, как и в других языках.

```erlang
5> 0.1 + 0.2.
0.30000000000000004
```

["Что нужно знать про арифметику с плавающей запятой"](http://habrahabr.ru/post/112953/)


### atom

Это некие константные значения, которые можно сравнивать друг с другом
на предмет совпадения.  Собственно, сравнивать -- это единственное,
что с ними можно делать.

```erlang
1> Color1 = green.
green
2> Color2 = red.
red
3> Color3 = green.
green
4> Color1 == Color2.
false
5> Color1 == Color3.
true
```

При этом они очень широко используются
в основном для "сопоставления с образцом" (pattern matching).

Пока можно считать, что это некий аналог перечислений (enum),
хотя это не совсем точно.

В документации и во всех книгах авторы рассказывают, что атомы
хранятся в специальной таблице в памяти и никогда не удаляются
оттуда. Поэтому их нельзя генерировать динамически.

**list\_to\_atom/1** опасен (не совсем очевидно, но **binary\_to\_term/1**
опасен таким же образом). А вот **list\_to\_existing_atom/1** безопасен.

Все-все эрланг разработчики это знают, но все равно иногда это
делают.

Атомы имеют глобальную область видимости (в пределах ноды) и занимают
1 машинное слово в памяти.

Интересно, что в эрланг нет типа данных **boolean**. А роль boolean
значений выполняют атомы **true** и **false**. Операции сравнения ==, <, >
и т.д. реализованы в языке так, что возвращают эти атомы.


### tuple

Кортеж -- структура данных, объединяющая несколько разных значений в одно.
Похож на список, но в отличие от списка имеет фиксированную длину.

Главная польза от кортежей идет в комплекте с сопоставлением с образцом.

Аналогом кортежа является **struct** в языке C. И внутри виртуальной
машины кортежи именно так и представлены.

```erlang
1> {5.2, 4.6}.
{5.2,4.6}
2> {5, 7, 9}.
{5,7,9}
3>
```

tagged tuple -- это отчасти компенсирует анонимность значений.

```erlang
3> {point, 5.2, 4.6}.
{point,5.2,4.6}
4> {point3D, 5, 7, 9}.
{point3D,5,7,9}
5> {user, 1, "Bob", 27}.
{user,1,"Bob",27}
{rect,{point,10,10},{point,20,20}}
6> {error, not_found}.
{error, not_found}.
```

Ну и кортежи могут быть вложены друг в друга на несколько уровней.

```erlang
7> {rect, {point, 10, 10}, {point, 20, 20}}.
```

Обычно кортежи бывают небольшими -- 2-5 элементов. Для небольших
кортежей смысл вложенных в них значений понятен из контекста.


### list

Однонаправленный связанный список (linked list).

В эрланге списки могут содержать элементы разных типов:

```erlang
1> [1,2,3,4,5].
[1,2,3,4,5]
2> [red, green, blue].
[red,green,blue]
3> [4.5, 77, hi, "hello", <<"hello">>].
[4.5,77,hi,"hello",<<"hello">>]
```

Могут быть вложенными друг в друга на несколько уровней:

```erlang
4> [1, 2, [3, 4, [5, 6], 7], 8, 9].
[1,2,[3,4,[5,6],7],8,9]
```

Могут содержать кортежи:

```erlang
5> [{point, 1, 2}, {point, 3, 4}, {point, 5, 6}].
[{point,1,2},{point,3,4},{point,5,6}]
```

И кортежи могут содержать внутри себя списки:

```erlang
6> {field, {width, 10}, {height, 20}, {points, [{point, 1,2}, {point, 3,4}]}}.
{field,{width,10},
    {height,20},
    {points,[{point,1,2},{point,3,4}]}}
```

С помощью вложенных друг в друга кортежей и списков можно описать любые,
даже очень сложные по структуре данные:

```erlang
{select,["email.email","address.state","account.name"],
        {"user",as,"u"},
        [{joins,[{left,{"email",as,"e"},[{pk,"eid"}]},
                 {left,"address",[{fk,"addr_id"}]},
                 {left,"account",[{pk,"aid"},{fk,"acc_id"}]}]}]
```

### record

Запись (record) -- улучшенный кортеж с именованными полями.
Представляет собой синтаксический сахар, добавленный в язык позже. На
этапе компиляции превращается в обычный кортеж, и имена полей
теряются.

```erlang
-record(user, {id = 0,
               name = "",
               age = 0
              }).
```

Эрланг предлагает синтаксис для создания записей, для чтения и модификации значений полей:

```erlang
User = #user{}.
User2 = #user{id = 5}.
User3 = #user{id = 5, name = "Bob", age = 24}.
UserId = User#user.id.
UserName = User#user.name.
User4 = User#user{id = 7}.
```

Ну и, разумеется, записи могут быть вложенны друг в друга, в списки, в кортежи.

```erlang
Users = [#user{id = 1}, #user{id = 2}, #user{id = 3}].
```

### map

Новый тип данных, появившийся в эрланг с 17-й версии.

До этого в эрланг не было нативной key-value структуры данных,
аналогичной словарю (dictionary) в Python или HashMap в Java.

Разница между map и record/tuple в том, что map позволяет динамически
добавлять/удалять элементы.

```erlang
1> Map1 = #{1 => {user, "Bob"}, 2 => {user, "Bill"}}.
 #{1 => {user,"Bob"},2 => {user,"Bill"}}
2> Map2 = Map1#{3 => {user, "Helen"}}.
 #{1 => {user,"Bob"},2 => {user,"Bill"},3 => {user,"Helen"}}
3> Map3 = Map2#{1 := {user, "Bob Bobovich"}}.
 #{1 => {user,"Bob Bobovich"},2 => {user,"Bill"},3 => {user,"Helen"}}
4> maps:get(1, Map3).
{user,"Bob Bobovich"}
5> maps:get(2, Map3).
{user,"Bill"}
6> maps:get(3, Map3).
{user,"Helen"}
```


### pid, port, reference

Эти типы являются идентификаторами.

**pid** является идентификатором потока, зная который, можно отправлять потоку сообщения.

```erlang
1> F = fun() -> timer:sleep(5000) end.
 #Fun<erl_eval.20.90072148>
2> Pid = spawn(F).
<0.36.0>
3> Pid ! hello.
hello
```

**port** является идентификатором специального процесса, связанного с сокетом.

```erlang
1> gen_tcp:listen(8080, []).
{ok,#Port<0.588>}
2> gen_udp:open(9090).
{ok,#Port<0.593>}
```

**reference** является индентификатором общего назначения, который можно
использовать по своему усмотрению.

Им можно пометить сообщение, отправленное
другому потоку, и ждать ответное сообщение, помеченное тем же ключом.

```erlang
1> Ref = make_ref().
 #Ref<0.0.0.30>
2> Pid = spawn(timer, sleep, [10000]).
<0.36.0>
3> Pid ! {Ref, hello}.
{#Ref<0.0.0.30>,hello}
```

Эрланг гарантирует, что **make\_ref** при каждом вызове генерирует новый уникальный ключ.


### fun

Анонимных функции, они же лямбды, они же замыкания.

```erlang
1> F = fun(Val) -> Val rem 2 =:= 0 end.
 #Fun<erl_eval.6.90072148>
2> lists:filter(F, [1,2,3,4,5,6]).
[2,4,6]
```

### binary

И, наконец, тип binary. Представляет собой просто последовательность байт.
Именно в таком виде мы получаем данные из сокета, из файла -- из внешнего мира.

**bit syntax**:

```erlang
8> Val1 = 512.
512
9> Val2 = 768.
768
10> Val3 = 32.
32
11> Bin = <<Val1:32/integer, Val2:16/integer, Val3:8/integer>>.
<<0,0,2,0,3,0,32>>
12> <<Val:32/integer, Rest/binary>> = Bin.
<<0,0,2,0,3,0,32>>
13> Val.
512
14> Rest.
<<3,0,32>>
```

Это значительно удобнее, чем сдвиги и маски, применяемые для манипуляций с байтами и битами
в других языках.

Эрланг умеет эффективно сериализовать и десериализовать свои типы данных в binary.
И имеет собственный компактный формат сериализации
[BERT (binary erlang term storage)](http://www.erlang.org/doc/apps/erts/erl_ext_dist.html).
И есть [библиотеки для многих других языков](http://bert-rpc.org/), реализующие этот формат.
Так что его можно брать для любого клиент-серверного приложения.

```erlang
16> Bin = term_to_binary([{user, "Bob"}, {user, "Bill"}]).
<<131,108,0,0,0,2,104,2,100,0,4,117,115,101,114,107,0,3,
66,111,98,104,2,100,0,4,117,115,101,...>>
17> binary_to_term(Bin).
[{user,"Bob"},{user,"Bill"}]
18> Bin2 = term_to_binary({1,2,3}).
<<131,104,3,97,1,97,2,97,3>>
19> binary_to_term(Bin2).
{1,2,3}
```
