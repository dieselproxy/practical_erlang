## Чат с комнатами

Итак, мы написали gen\_server. Теперь давайте сделаем на его базе
что-нибудь полезное.

Пусть это будет чат с комнатами. Пользователи могут создавать комнаты,
присоединяться к уже существующим комнатам, писать сообщения и
получать историю сообщений для данной комнаты.

Нужно реализовать следующие функции:

### start()

запускает сервер и возвращает его pid.


### create_room(Server, RoomName)

Принимает pid сервера и имя комнаты, создает новую комнату, генерирует
для нее уникальный идентификатор, сохраняет комнату в состоянии
сервера.

Тип данных для имени комнаты и ее индентификатора выберите
сами, какие вы считаете нужными.

Пусть в чате будет лимит -- не больше 5-ти комнат. Если лимит не превышен,
то создается новая комната, и функция возвращает _{ok, RoomId}_.
Если лимит превышен, то функция возвращает _{error, room\_limit}_.


### remove_room(Server, RoomId)

Принимает pid сервера и идентификатор комнаты.
Если такая комната есть, то удаляет ее и возвращает атом _ok_.
Если такой комнаты нет, то возвращает _{error, room\_not\_found}_.


### get_rooms(Server)

Принимает pid сервера, возвращает список комнат в виде кортежей _[{RooId, RoomName}]_.


### add_user(Server, RoomId, UserName)

Для простоты не будем вводить сложный объект **User** со многими
аттрибутами, а ограничимся только строкой **UserName**. Будем считать,
что пользователь полностью определяется этой строкой :)

Функция принимает pid сервера, идентификатор комнаты и имя
пользователя.  Если комната найдена, пользователь добавляется в
комнату, и функция возвращает атом _ok_. Если такой комнаты нет, то
функция возвращает _{error, room\_not\_found}_. Если пользователь
уже в комнате, то функция возвращает _{error, user\_is\_in\_room}_.


### remove_user(Server, RoomId, UserName)

Принимает pid сервера, идентификатор комнаты и имя пользователя.  Если
комната найдена и данный пользователь в ней есть, то функция удаляет
пользователя из комнаты и возвращает атом _ok_.

Если такой комнаты нет, то функция возвращает _{error, room\_not\_found}_.
Если комната есть, но в ней нет такого
пользователя, то функция возвращает _{error, user\_not\_in\_room}_.


### get_users_list(Server, RoomId)

Принимает pid сервера и идентификатор комнаты. Возвращает список имен пользователей _{ok, [Name]}_.
Если такой комнаты нет, то функция возвращает _{error, room\_not\_found}_.


### send_message(Server, RoomId, UserName, Message)

Принимает pid сервера, идентификатор комнаты, имя пользователя и
сообщение от пользователя.  Тип данных для сообщения выберите сами.

Функция сохраняет сообщение в истории сообщений для данной комнаты.

Какой-либо бродкаст сообщения всем пользователям реализовывать не
нужно, потому что у нас нет сущностей, представляющих пользователей,
которые способны принимать сообщения.  (Понятно, что в этом случае
каждого пользователя должен представлять какой-то отдельный поток).

Разумеется, нужно обработать ошибки и возвращать
_{error, room\_not\_found}_ или _{error, user\_not\_in\_room}_.
Если добавление завершилось успешно, то функция возвращает _ok_.


### get_messages_history(Server, RoomId)

Принимает pid сервера и идентификатор комнаты, возвращает историю
сообщений в виде списка кортежей _{ok, [{UserName, Message}]}_.
Или _{error, room\_not\_found}_.


В случае сомнений, как должна себя вести та или иная функция, смотрите юнит тесты :)
