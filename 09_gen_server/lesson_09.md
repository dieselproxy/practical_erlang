# gen_server

Хороший подход к изучению gen_server – написать его самому. Такой
подход выбрали и Joe Armstrong (Programming Erlang, глава 16), и Fred
Hebert (LYSE, глава What is OTP?).

Пойдем и мы тем же путем, напишем свой gen_server.


## 1-й этап, простейший цикл.

src/gs1.erl

Нам нужен поток, который никогда не завершается. Используем для этого
бесконечную рекурсию.

Поток запускается, входит в функцию **loop**, проверяет почтовый ящик,
обрабатывает сообщения, и опять входит в функцию **loop**.  Тут важно,
чтобы это была хвостовая рекурсия. Иначе будет расти память на стеке и
в какой-то момент нода упадет из-за нехватки памяти.


## 2-й этап, цикл c состоянием.

src/gs2.erl

Добавим хранимое состояние. Теперь функция **loop** получает
аргумент. Это состояние потока. После **spawn** он имеет некое
начальное состояние. В данном случае это массив. Но это может быть
любая структура данных.

Затем поток может модифицировать эту структуру, и в последующие вызовы
**loop** передавать новое состояние. Таким образом, не имея
изменяемых переменных, мы все-таки имеем изменяемое состояние потока в
его стеке.

Обрабатываем сообщения: add, remove, check, show.  Тут мы усложнили
форматы сообщений, которые умеет обрабатывать поток.  И сформировали
некое АПИ: добавление и удаление элементов и вывод их на консоль.

Предусмотрим нормальное завершение потока. Для этого добавим обработку
сообщения **stop**, получив которое, поток не будет вызывать **loop**.
И, таким образом, завершится.

Логируем получение неизвестных сообщений.


## 3-й этап, горячее обновление кода.

src/gs3.erl

Здесь мы заменили вызовы **loop(State)** на **?MODULE:loop(State)**.
Тем самым мы заменили локальный вызов функции (только по ее имени),
на глобальный вызов (по имени модуля и функции). Для глобального
вызова действует горячее обновление кода. Как это работает?

Нода может держать в памяти 2 версии модуля. Допустим, при создании
потока и вызове loop, он начал выполнять версию 1 и прошел несколько
итераций рекурсии. Тем временем, мы изменили код, скомпилировали, и
загрузили в ноду версию 2. Пока текущая итерация не завершена, поток
все еще выполняет версию 1. Но следующий вызов loop уже попадет в
версию 2.

На следующих этапах мы уже не будем останавливать поток, а будем
пользоваться горячим обновлением кода.


## 4-й этап, публичный АПИ модуля.

src/gs4.erl

Дальше взаимодействие с сервером будет усложняться, поэтому спрячем
отправку сообщений внутри функций.


## 5-й этап, синхронный ответ на сообщение.

src/gs5.erl

Это хорошо, что наш сервер умеет хранить состояние и менять его в
зависимости от запросов клиентов. Но было бы неплохо, чтобы сервер
умел что-нибудь отвечать клиенту.

Для этого нужно передать Pid клиента внутри сообщения.  А сервер
должен послать ответ на этот Pid.

Теперь для клиента взаимодействие с сервером выглядит как синхронный
вызовы функции, и получение ответа из нее.


## 6-й этап, добавляем таймаут.

src/gs6.erl

Мы блокируем поток клиента, и это не всегда хорошо. Правильно будет позволить
клиенту задать timeout, как долго он готов ожидать ответ сервера.

timeout можно вынести в аргументы, и предоставить каждую АПИ-функцию в
двух вариантах, с явным указанием timeout и без указания. В настоящем
gen_server так и сделано.  Но мы сейчас не будем сильно усложнять код,
а просто добавим 5-ти секундный timeout в функцию receive.


## 7-й этап, убираем дублирование кода в публичном АПИ.

src/gs7.erl


## 8-й этап, также убираем дублирование кода в loop.

src/gs8.erl


## 9-й этап, матчинг сообщений по Ref.

src/gs9.erl

Такой вариант еще далек от совершенства. Поток-клиент любое сообщение
в своем почтовом ящике считает ответом сервера. А там могут быть совсем
другие сообщения.

Чтобы исправить эту проблему, нужно добавить уникальный идентификатор
в сообщение, и вернуть его в ответе. Для таких целей у нас есть
отдельный тип данных -- **reference**, и функция **make_ref**, которая
умеет генерировать уникальные значения такого типа.


## 10-й этап, монитор, обработка ошибок.

src/gs10.erl

И последнее: если на сервере при обработке сообщения возникнет ошибка,
но неплохо было бы сообщить клиенту об этом.

Тут мы немного забегаем вперед, ибо обработка ошибок в одном потоке из
другого потока, это тема следующих уроков. Но хорошая реализация
требует, так что делаем :)

Мы устанавливаем монитор, и теперь, если серверный поток упадет, то
клиентский получит сообщение **{'DOWN', MRef, process, Pid, Reason}**.
Когда клиент получает ответ, он снимает монитор. Так что
монитор действует только на время обработки запроса клиента.

И нам теперь не нужно создавать ссылку с помощью make_ref, потому что
monitor возвращает аналогичную ссылку.

```
gs10:call(Pid, hello)
```

## Итог

Итак, мы написали свой gen_server. Мы умеем:
- принимать запросы от клиента и отвечать на них;
- хранить и модифицировать состояние;
- делать горячее обновление кода;
- обрабатывать ошибки.

Настоящий gen\_server, входящий в состав OTP, устроен сложнее, конечно.
Но концептуально он работает именно так.

Код gen_server отшлифован за многие годы использования во многих
высоконагруженных проектах.  Так что нужно пользоваться именно им. И в
следующем уроке мы научимся этому.
